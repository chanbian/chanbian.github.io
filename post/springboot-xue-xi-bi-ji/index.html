<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SpringBoot学习笔记 | 蝉变</title>
<link rel="shortcut icon" href="https://chanbian.github.io/favicon.ico?v=1609315571815">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://chanbian.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="SpringBoot学习笔记 | 蝉变 - Atom Feed" href="https://chanbian.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="SpringBoot学习笔记
0、预备知识
0.1 Maven
Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecyc..." />
    <meta name="keywords" content="springboot" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://chanbian.github.io">
  <img class="avatar" src="https://chanbian.github.io/images/avatar.png?v=1609315571815" alt="">
  </a>
  <h1 class="site-title">
    蝉变
  </h1>
  <p class="site-description">
    「你不是没有才华，你只是在积蓄力量。」
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SpringBoot学习笔记
            </h2>
            <div class="post-info">
              <span>
                2020-12-30
              </span>
              <span>
                8 min read
              </span>
              
                <a href="https://chanbian.github.io/tag/8R4enqZIS/" class="post-tag">
                  # springboot
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="springboot学习笔记">SpringBoot学习笔记</h1>
<h2 id="0-预备知识">0、预备知识</h2>
<h3 id="01-maven">0.1 Maven</h3>
<p>Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</p>
<ul>
<li>可用于管理项目的编译、测试、运行、打包、安装。</li>
<li>生成基础<strong>SpringBoot</strong>项目时就有是否使用Maven 的选项。</li>
<li>maven工程目录结构如下（与<strong>SpringBoot</strong>项目结构十分相似）
<ul>
<li><img src="https://chanbian.github.io/post-images/1609315526121.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="1-spring与springboot简介">1、Spring与SpringBoot简介</h2>
<h2 id="11-spring">1.1 Spring</h2>
<ul>
<li>
<p>任何实际的应用程序都是由很多组件组成的，每个组件负责整个应用功能的一部分，这些组件需要与其他的应用元素进行协调以完成自己的任务。当应用程序运行时，需要以某种方式创建并引入这些组件。</p>
</li>
<li>
<p>Spring的核心是提供了一个容器（container），通常称为Spring应用上下文（Spring applicationcontext），它们会创建和管理应用组件。这些组件也可以称为bean，会在Spring应用上下文中装配在一起，从而形成一个完整的应用程序。这就像砖块、砂浆、木材、管道和电线组合在一起，形成一栋房子似的。</p>
</li>
<li>
<p>将bean装配在一起的行为是通过一种基于依赖注入（dependency injection，DI）的模式实现的。此时，组件不会再去创建它所依赖的组件并管理它们的生命周期，使用依赖注入的应用依赖于单独的实体（容器）来创建和维护所有的组件，并将其注入到需要它们的bean中。通常，这是通过构造器参数和属性访问方法来实现的。</p>
</li>
<li>
<p>在Spring技术中，自动配置起源于所谓的自动装配（autowiring）和组件扫描（componentscanning）。借助组件扫描技术，Spring能够自动发现应用类路径下的组件，并将它们创建成Spring应用上下文中的bean。借助自动装配技术，Spring能够自动为组件注入它们所依赖的其他bean。</p>
</li>
<li>
<figure data-type="image" tabindex="2"><img src="E:/DistDocument/%E5%91%A8%E6%8A%A5/rshy/2020_11_20/images/3.jpg" alt="" loading="lazy"></figure>
</li>
</ul>
<h3 id="12-springboot">1.2 SpringBoot</h3>
<ul>
<li>随着Spring Boot的引入，自动配置的能力已经远远超出了组件扫描和自动装配。Spring Boot是Spring框架的扩展，提供了很多增强生产效率的方法。最为大家所熟知的增强方法就是自动配置（autoconfiguration），Spring Boot能够基于类路径中的条目、环境变量和其他因素合理猜测需要配置的组件并将它们装配在一起。</li>
<li>Spring Boot用来简化Spring应用开发，约定大于配置， 去繁从简，just run就能创建一个独立的，产品级别的应用。</li>
<li>优点在于：
<ul>
<li>快速创建独立运行的Spring项目以及与主流框架集成</li>
<li>使用嵌入式的Servlet容器，应用无需打成WAR包</li>
<li>starters自动依赖与版本控制</li>
<li>大量的自动配置，简化开发，也可修改默认值</li>
<li>无需配置XML，无代码生成，开箱即用</li>
<li>准生产环境的运行时应用监控</li>
<li>与云计算的天然集成</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="E:/DistDocument/%E5%91%A8%E6%8A%A5/rshy/2020_11_20/images/7.PNG" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="E:/DistDocument/%E5%91%A8%E6%8A%A5/rshy/2020_11_20/images/8.PNG" alt="" loading="lazy"></figure>
<h2 id="2-spring-boot项目的创建">2、Spring Boot项目的创建</h2>
<h3 id="21项目创建方式一使用spring-initializr-的-web页面创建项目">2.1项目创建方式一：使用Spring Initializr 的 Web页面创建项目</h3>
<p>1、打开  https://start.spring.io/</p>
<p>2、填写项目信息，通过在Add Dependencies来指明依赖，最后点击GENERATE即可生成。</p>
<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>
<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>
<p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。<br>
<img src="https://chanbian.github.io/post-images/1609315341041.png" alt="" loading="lazy"><br>
<img src="https://chanbian.github.io/post-images/1609315361153.png" alt="" loading="lazy"></p>
<h3 id="22项目创建方式二使用-idea-直接创建项目">2.2项目创建方式二：使用 IDEA 直接创建项目</h3>
<p>1、创建一个新项目</p>
<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>
<p>3、填写项目信息</p>
<p>4、选择初始化的组件（初学勾选 Web 即可）</p>
<p>5、填写项目路径</p>
<p>6、等待项目构建成功<br>
<img src="https://chanbian.github.io/post-images/1609315378090.png" alt="" loading="lazy"><br>
<img src="https://chanbian.github.io/post-images/1609315382501.png" alt="" loading="lazy"><br>
<img src="https://chanbian.github.io/post-images/1609315386084.png" alt="" loading="lazy"><br>
<img src="https://chanbian.github.io/post-images/1609315395152.png" alt="" loading="lazy"></p>
<h2 id="3-spring-boot项目结构">3、Spring Boot项目结构</h2>
<p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p>
<ul>
<li>
<p>程序的主启动类</p>
</li>
<li>
<p>一个 application.properties 配置文件</p>
</li>
<li>
<p>一个 测试类</p>
</li>
<li>
<p>一个 pom.xml</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chanbian.github.io/post-images/1609315408829.png" alt="" loading="lazy"></figure>
<h3 id="31-主启动类">3.1 主启动类</h3>
<p>默认的主启动类如下所示：</p>
<pre><code class="language-java">//@SpringBootApplication 
@SpringBootApplication
public class SpringbootApplication {
   public static void main(String[] args) {
      SpringApplication.run(SpringbootApplication.class, args);
   }
}
</code></pre>
<h4 id="1常见的注解说明">（1）常见的注解说明：</h4>
<h5 id="springbootapplication"><strong>@SpringBootApplication</strong></h5>
<ul>
<li>来标注一个主程序类，标注在某个类上说明这个类是SpringBoot的主配置类 ，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</li>
</ul>
<h5 id="componentscan"><strong>@ComponentScan</strong></h5>
<ul>
<li>注解在Spring中很重要 ,它对应XML配置中的元素。</li>
</ul>
<h5 id="springbootconfiguration">@SpringBootConfiguration</h5>
<ul>
<li>SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</li>
</ul>
<h5 id="configuration">@Configuration</h5>
<ul>
<li>说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</li>
</ul>
<h5 id="enableautoconfiguration">@EnableAutoConfiguration</h5>
<ul>
<li>开启自动配置功能</li>
<li>自动配置的源头在spring.factories，用于管理所有的自动配置文件</li>
</ul>
<h4 id="2springapplication">（2）SpringApplication</h4>
<p>这个类主要做了以下四件事情：</p>
<ul>
<li>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
</li>
<li>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
</li>
<li>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
</li>
<li>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
</li>
<li>
<p>构造器如下：</p>
</li>
<li>
<pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
</code></pre>
</li>
</ul>
<h4 id="3run方法流程">（3）run方法流程</h4>
<figure data-type="image" tabindex="6"><img src="https://chanbian.github.io/post-images/1609315478887.jpg" alt="" loading="lazy"></figure>
<h3 id="32-applicationproperties-配置文件">3.2  application.properties 配置文件</h3>
<h3 id="33-测试类">3.3 测试类</h3>
<h3 id="34-pomxml">3.4  pom.xml</h3>
<p>pom.xml用于管理Spring Boot项目的依赖。打开pom.xml，可以看到Spring Boot项目的依赖，其中：</p>
<ul>
<li><strong>导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中，管理者就需要手动配置版本了；</strong></li>
<li>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；也可以自己自定义 starter；</li>
</ul>
<pre><code class="language-xml">&lt;!-- 父依赖 --&gt;
&lt;!-- 依赖一个父项目，主要是管理项目的资源过滤及插件！ --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!-- web场景启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;!--spring-boot-starter-web帮我们导入了web模块正常运行所依赖的组件；--&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- springboot单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;!-- 剔除依赖 --&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 打包插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h2 id="4-spring与jdbc">4、Spring与JDBC</h2>
<p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<ul>
<li>
<p>Sping Data 官网：https://spring.io/projects/spring-data</p>
</li>
<li>
<p>数据库相关的启动器，可以参考官方文档：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</p>
</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">SpringBoot学习笔记</a>
<ul>
<li><a href="#0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">0、预备知识</a>
<ul>
<li><a href="#01-maven">0.1 Maven</a></li>
</ul>
</li>
<li><a href="#1-spring%E4%B8%8Espringboot%E7%AE%80%E4%BB%8B">1、Spring与SpringBoot简介</a></li>
<li><a href="#11-spring">1.1 Spring</a>
<ul>
<li><a href="#12-springboot">1.2 SpringBoot</a></li>
</ul>
</li>
<li><a href="#2-spring-boot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA">2、Spring Boot项目的创建</a>
<ul>
<li><a href="#21%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80%E4%BD%BF%E7%94%A8spring-initializr-%E7%9A%84-web%E9%A1%B5%E9%9D%A2%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">2.1项目创建方式一：使用Spring Initializr 的 Web页面创建项目</a></li>
<li><a href="#22%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%BA%8C%E4%BD%BF%E7%94%A8-idea-%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">2.2项目创建方式二：使用 IDEA 直接创建项目</a></li>
</ul>
</li>
<li><a href="#3-spring-boot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">3、Spring Boot项目结构</a>
<ul>
<li><a href="#31-%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB">3.1 主启动类</a>
<ul>
<li><a href="#1%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E">（1）常见的注解说明：</a>
<ul>
<li><a href="#springbootapplication"><strong>@SpringBootApplication</strong></a></li>
<li><a href="#componentscan"><strong>@ComponentScan</strong></a></li>
<li><a href="#springbootconfiguration">@SpringBootConfiguration</a></li>
<li><a href="#configuration">@Configuration</a></li>
<li><a href="#enableautoconfiguration">@EnableAutoConfiguration</a></li>
</ul>
</li>
<li><a href="#2springapplication">（2）SpringApplication</a></li>
<li><a href="#3run%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B">（3）run方法流程</a></li>
</ul>
</li>
<li><a href="#32-applicationproperties-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3.2  application.properties 配置文件</a></li>
<li><a href="#33-%E6%B5%8B%E8%AF%95%E7%B1%BB">3.3 测试类</a></li>
<li><a href="#34-pomxml">3.4  pom.xml</a></li>
</ul>
</li>
<li><a href="#4-spring%E4%B8%8Ejdbc">4、Spring与JDBC</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://chanbian.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello World！
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://chanbian.github.io/" target="_blank">  蝉变__chanbian</a>
  <a class="rss" href="https://chanbian.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
